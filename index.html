<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bruce JS Designer</title>
<style>
body { margin:0; padding:16px; background:#1a0033; color:#fff; font-family:'Segoe UI',sans-serif; }
.container { max-width:960px; margin:auto; }
h1 { text-align:center; margin-bottom:12px; }
canvas { display:block; margin:0 auto 12px; background:#000; border-radius:6px; image-rendering:pixelated; touch-action: none; }
.sliders { display:flex; flex-wrap:wrap; gap:12px; margin-bottom:12px; }
.sliders label { flex:1 1 45%; display:flex; flex-direction:column; }
input, select { width:100%; padding:6px; border-radius:8px; border:none; background:#4b2e83; color:#fff; }
input[type="color"] { padding:0; height:32px; }
.buttons { display:flex; flex-wrap:wrap; gap:8px; margin-top:12px; }
.buttons button { flex:1 1 0; min-width:100px; padding:10px; border:none; border-radius:10px; background:#6c43b2; color:#fff; font-weight:bold; cursor:pointer; text-align:center; }
.buttons button:hover { background:#8457d6; }
.buttons .danger { background:#ff4d6d; } 
.buttons .danger:hover { background:#ff1a3c; }
.buttons .export { background:#4dff88; color:#000; } 
.buttons .export:hover { background:#2cff70; }
code { display:block; background:#2b0055; border:1px solid #4b2e83; padding:12px; border-radius:8px; white-space:pre-wrap; margin-top:12px; max-height:300px; overflow:auto; }
.credits { position:fixed; bottom:8px; right:16px; font-size:0.8rem; }
.toggle { padding:10px; border-radius:10px; border:none; background:#6c43b2; color:#fff; cursor:pointer; font-weight:bold; }
.toggle.on { background:#4dff88; color:#000; }
@media(max-width:600px){ .sliders label { flex:1 1 100%; } .buttons button { flex:1 1 48%; } }
</style>
</head>
<body>
<div class="container">
<h1>Bruce JS Designer</h1>

<canvas id="screen" width="320" height="170"></canvas>

<div class="sliders">
  <label>Device:
    <select id="device"></select>
  </label>
  <label>Snap to Grid:
    <button id="snapToggle" class="toggle">OFF</button>
  </label>
  <label>Text
    <input type="text" id="text">
  </label>
  <label>Layer
    <select id="shapeSelect"></select>
  </label>
  <label>File name
    <input type="text" id="fileName" value="app">
  </label>
  <label>Color
    <input type="color" id="color">
  </label>
</div>

<div class="buttons">
  <button onclick="addItem('fillRect')">FillRect</button>
  <button onclick="addItem('rect')">Rect</button>
  <button onclick="addItem('line')">Line</button>
  <button onclick="addItem('circle')">Circle</button>
  <button onclick="addItem('fillCircle')">FillCircle</button>
  <button onclick="addItem('text')">Text</button>
  <button onclick="duplicateItem()">Duplicate</button>
  <button class="danger" onclick="deleteItem()">Delete</button>
  <button class="export" onclick="exportJS()">Export JS</button>
</div>

<code id="code"></code>
<div class="credits">
  <a href="https://discord.com/users/sloth110000" target="_blank" style="color:#aaa;text-decoration:none">Made by SLOTH</a>
</div>

<script>
const canvas = document.getElementById("screen");
const ctx = canvas.getContext("2d");
const deviceSelect = document.getElementById("device");
const shapeSelect = document.getElementById("shapeSelect");
const textInput = document.getElementById("text");
const colorInput = document.getElementById("color");
const code = document.getElementById("code");
const snapToggle = document.getElementById("snapToggle");

let items = [];
let selected = null;
let currentDevice;
let gridSize = 10; 
let snapOn = false;
let dragging = null, resizing = false, resizeHandle = null, offsetX = 0, offsetY = 0;
let showGrid = false;

const devices = {
  "M5StickC / M5Cardputer": [240, 135],
  "LilyGO T-Embed": [320, 170]
};

function populateDeviceDropdown() {
  deviceSelect.innerHTML = "";
  for(let name in devices){
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    deviceSelect.appendChild(opt);
  }
  currentDevice = deviceSelect.value;
}
populateDeviceDropdown();

snapToggle.addEventListener("click",()=>{ 
  snapOn=!snapOn; 
  snapToggle.textContent = snapOn?"ON":"OFF"; 
  snapToggle.classList.toggle("on", snapOn); 
});

function getRandomColor() {
  const letters = "0123456789ABCDEF";
  let c = "#";
  for(let i=0;i<6;i++) c += letters[Math.floor(Math.random()*16)];
  return c;
}

function clamp(value, min, max) { return Math.min(Math.max(value, min), max); }

function addItem(type){
  const obj = {type, x:40, y:40, w:40, h:40, size:2, color:getRandomColor(), text:"Hello"};
  if(type.includes("circle") || type.includes("fillCircle")) obj.w = obj.h = 20;
  if(snapOn){ obj.x = Math.round(obj.x/gridSize)*gridSize; obj.y = Math.round(obj.y/gridSize)*gridSize; }
  items.push(obj);
  selected = obj;
  updateLayerSelect();
  render();
}

function duplicateItem(){
  if(!selected) return;
  const copy = {...selected};
  copy.x += 10; copy.y += 10;
  if(snapOn){ copy.x = Math.round(copy.x/gridSize)*gridSize; copy.y = Math.round(copy.y/gridSize)*gridSize; }
  items.push(copy);
  selected = copy;
  updateLayerSelect();
  render();
}

function deleteItem(){ if(!selected) return; items = items.filter(i=>i!==selected); selected=null; updateLayerSelect(); render(); }

function render(){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,canvas.width,canvas.height);

  if(showGrid){
    ctx.strokeStyle="#2b0055"; ctx.lineWidth=0.5;
    for(let x=0;x<=canvas.width;x+=gridSize){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for(let y=0;y<=canvas.height;y+=gridSize){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
  }

  const W = canvas.width;
  const H = canvas.height;

  items.forEach(i=>{
    i.x = clamp(i.x,0,W-i.w);
    i.y = clamp(i.y,0,H-i.h);

    ctx.save(); ctx.translate(i.x,i.y);
    ctx.strokeStyle=ctx.fillStyle=i.color; ctx.lineWidth=2;

    if(i.type==="fillRect") ctx.fillRect(0,0,i.w,i.h);
    if(i.type==="rect") ctx.strokeRect(0,0,i.w,i.h);
    if(i.type==="line"){ ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(i.w,i.h); ctx.stroke(); }
    if(i.type==="circle"){ ctx.beginPath(); ctx.arc(i.w/2,i.h/2,i.w/2,0,Math.PI*2); ctx.stroke(); }
    if(i.type==="fillCircle"){ ctx.beginPath(); ctx.arc(i.w/2,i.h/2,i.w/2,0,Math.PI*2); ctx.fill(); }
    if(i.type==="text"){ ctx.font=`${i.size*8}px Arial`; ctx.fillText(i.text,0,i.h/2+i.size*4); }

    if(i===selected){
      ctx.strokeStyle="blue"; ctx.lineWidth=1.5;
      ctx.strokeRect(0,0,i.w,i.h);
      const handles=[{x:-5,y:-5},{x:i.w-5,y:-5},{x:-5,y:i.h-5},{x:i.w-5,y:i.h-5}];
      handles.forEach(h=>{ ctx.fillStyle="blue"; ctx.beginPath(); ctx.arc(h.x+5,h.y+5,5,0,Math.PI*2); ctx.fill(); });
    }

    ctx.restore();
  });

  syncUI();
  generateCode();
}

function getMousePos(e){ 
  const rect=canvas.getBoundingClientRect(); 
  return { x:e.touches?e.touches[0].clientX-rect.left:e.clientX-rect.left, y:e.touches?e.touches[0].clientY-rect.top:e.clientY-rect.top }; 
}

canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('touchstart', startDrag,{passive:false});
document.addEventListener('mousemove', drag);
document.addEventListener('touchmove', drag,{passive:false});
document.addEventListener('mouseup', stopDrag);
document.addEventListener('touchend', stopDrag);

function startDrag(e){
  const pos=getMousePos(e);
  showGrid=false;
  for(let i=items.length-1;i>=0;i--){
    const it=items[i];
    const corners=[{name:'tl',x:it.x-5,y:it.y-5},{name:'tr',x:it.x+it.w-5,y:it.y-5},{name:'bl',x:it.x-5,y:it.h+it.y-5},{name:'br',x:it.x+it.w-5,y:it.h+it.y-5}];
    for(let h of corners){ 
      if(pos.x>=h.x&&pos.x<=h.x+10&&pos.y>=h.y&&pos.y<=h.y+10){ 
        dragging=it; resizing=true; resizeHandle=h.name; selected=it; showGrid=true; updateLayerSelect(); render(); return; 
      } 
    }
    if(pos.x>=it.x && pos.x<=it.x+it.w && pos.y>=it.y && pos.y<=it.y+it.h){ 
      dragging=it; offsetX=pos.x-it.x; offsetY=pos.y-it.y; selected=it; showGrid=true; updateLayerSelect(); render(); return; 
    }
  }
}

function drag(e){
  if(!dragging) return; e.preventDefault();
  const pos = getMousePos(e);

  if(resizing){
    let newX = dragging.x;
    let newY = dragging.y;
    let newW = dragging.w;
    let newH = dragging.h;
    const minSize = 5;

    if(resizeHandle.includes('t')){
      newY = Math.min(pos.y, dragging.y + dragging.h - minSize);
      newH = dragging.h + (dragging.y - newY);
    }
    if(resizeHandle.includes('b')){
      newH = Math.max(minSize, pos.y - dragging.y);
    }
    if(resizeHandle.includes('l')){
      newX = Math.min(pos.x, dragging.x + dragging.w - minSize);
      newW = dragging.w + (dragging.x - newX);
    }
    if(resizeHandle.includes('r')){
      newW = Math.max(minSize, pos.x - dragging.x);
    }

    newX = clamp(newX,0,canvas.width-newW);
    newY = clamp(newY,0,canvas.height-newH);
    newW = clamp(newW,minSize,canvas.width-newX);
    newH = clamp(newH,minSize,canvas.height-newY);

    if(snapOn){
      dragging.x = Math.round(newX/gridSize)*gridSize;
      dragging.y = Math.round(newY/gridSize)*gridSize;
      dragging.w = Math.round(newW/gridSize)*gridSize;
      dragging.h = Math.round(newH/gridSize)*gridSize;
    } else {
      dragging.x = newX;
      dragging.y = newY;
      dragging.w = newW;
      dragging.h = newH;
    }

  } else {
    let newX = pos.x - offsetX;
    let newY = pos.y - offsetY;
    if(snapOn){
      newX = Math.round(newX/gridSize)*gridSize;
      newY = Math.round(newY/gridSize)*gridSize;
    }
    dragging.x = clamp(newX,0,canvas.width-dragging.w);
    dragging.y = clamp(newY,0,canvas.height-dragging.h);
  }

  showGrid = true;
  render();
}

function stopDrag(){ dragging=null; resizing=false; resizeHandle=null; showGrid=false; render(); }

function updateLayerSelect(){
  shapeSelect.innerHTML="";
  items.forEach((i,idx)=>{ 
    const o=document.createElement("option"); 
    o.value=idx; 
    o.text=`${i.type} ${idx+1}`; 
    if(i===selected) o.selected=true; 
    shapeSelect.appendChild(o); 
  });
}
shapeSelect.onchange=e=>{ selected=items[e.target.value]; render(); }

function syncUI(){ if(!selected) return; textInput.value=selected.text; colorInput.value=selected.color; }
textInput.addEventListener("input",()=>{ if(selected){selected.text=textInput.value; render();} });
colorInput.addEventListener("input",()=>{ if(selected){selected.color=colorInput.value; render();} });

function rgb(hex){ hex=hex.replace("#",""); return [parseInt(hex.substr(0,2),16),parseInt(hex.substr(2,2),16),parseInt(hex.substr(4,2),16)]; }

function generateCode(){
  const dev = devices[currentDevice];
  const W = dev[0], H = dev[1];
  let out = `// Device: ${currentDevice}\n// Made using Bruce JS Designer\n`;
  out += `var keyboard = require('keyboard');\n`;
  out += `var display = require('display');\n`;
  out += `var sprite = display.createSprite();\n\n`;
  out += `while(true) {\n`;
  out += `    if(keyboard.getEscPress(true)) break;\n`;
  out += `    sprite.fill(0);\n\n`;

  items.forEach(i => {
    const scaleX = W / canvas.width;
    const scaleY = H / canvas.height;
    const x = Math.round(i.x * scaleX);
    const y = Math.round(i.y * scaleY);
    const w = Math.round(i.w * scaleX);
    const h = Math.round(i.h * scaleY);
    const c = rgb(i.color).join(',');

    if(i.type==="fillRect") out += `    sprite.drawFillRect(${x}, ${y}, ${w}, ${h}, display.color(${c}));\n`;
    if(i.type==="rect") out += `    sprite.drawRect(${x}, ${y}, ${w}, ${h}, display.color(${c}));\n`;
    if(i.type==="line") out += `    sprite.drawLine(${x}, ${y}, ${x+w}, ${y+h}, display.color(${c}));\n`;
    if(i.type==="circle") out += `    sprite.drawCircle(${x + Math.floor(w/2)}, ${y + Math.floor(h/2)}, ${Math.floor(w/2)}, display.color(${c}));\n`;
    if(i.type==="fillCircle") out += `    sprite.drawFillCircle(${x + Math.floor(w/2)}, ${y + Math.floor(h/2)}, ${Math.floor(w/2)}, display.color(${c}));\n`;
    if(i.type==="text") out += `    sprite.setTextSize(${i.size});\n    sprite.setTextColor(${c});\n    sprite.drawText("${i.text}", ${x}, ${y});\n`;
  });

  out += `\n    sprite.pushSprite();\n`;
  out += `}\n`;

  code.textContent = out;
}

function exportJS(){ 
  const name=document.getElementById("fileName").value||"app"; 
  const blob=new Blob([code.textContent],{type:"text/javascript"}); 
  const a=document.createElement("a"); 
  a.href=URL.createObjectURL(blob); 
  a.download=name+".js"; 
  a.click(); 
}

deviceSelect.addEventListener("change",()=>{currentDevice=deviceSelect.value; generateCode();});

render(); 
updateLayerSelect();
</script>
</body>
</html>
